Package postfix;

Helpers
    lettre = [['a' .. 'z'] + ['A' .. 'Z']];
    chiffre = ['0' .. '9'];
    alpha = [lettre + ['_' + '$']];
    alphanum = [lettre + chiffre];
    entier = ('+'|'-')? chiffre chiffre*;


Tokens

    espaces = (' ' | 13 | 10)+;
    commentaire= '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);
    l_accolade='{';
    r_accolade='}';
    l_par = '(';
    r_par = ')';
    non = '!';
    mult = '*';
    div = '/';
    plus = '+';
    minus = '-';


    vrai = 'vrai';
    faux = 'faux';
    equal = '=';
    less = '<';
    et = '&';
    ou = '|';
    mod = '%';

    t_huit = '_';
    saut_de_ligne = '\n';
    point_virgule = ';';
    brackopen  = '[';
    brackclose = ']';
    semicol    = ':';
    virgule = ',';
    retour = 'retour';
    lire = 'lire';
    ecrire = 'ecrire';

    si = 'if';
    sinon = 'sinon';
    alors = 'alors';
    tantque = 'tantque';
    faire = 'faire';
    number = chiffre+;
    entier = 'entier';
    identif = alpha alphanum*;
Ignored Tokens
    espaces,commentaire;

Productions
programme = {programme} listedecvar listedecfonc ;

s = {ou} s ou o | {o} o;
o = {et} o et e | {e} e;
e = {equal} e equal p | {less} e less p | {p} p;
p = {plus} p plus m | {minus} p minus m | {m} m;
m = {milt} m mult n | {div} m div n | {n} n;
n = {non} non n | {f} f;
f = {parentese} l_par s r_par | {number} number | {vrai} vrai | {faux} faux | {variable} var | {appelfonc} appelfonc
                                                | {lire} lire l_par r_par ;



appelfonc = {appelfonction} identif l_par listeexp r_par ;
listeexp = {listedeexpression} s listeexpbis | ;
listeexpbis = {restelistedeexpression} virgule s listeexpbis | ;

instr = {afect} var equal s point_virgule |
    {tantque} tantque s faire instrbloc |
    {fonc} identif l_par listeexp r_par point_virgule|
    {si} si s alors instrbloc |
    {sinon} si s alors thenbranch sinon elsebranch |
    {retour} retour s point_virgule |
    {ecrire} ecrire l_par s r_par point_virgule;


instrbloc ={listedinstr} l_accolade listeinstr r_accolade ;
thenbranch = {thenbranch} instrbloc;
elsebranch = {elsebranch} instrbloc;
listeinstr = {listdeinstr}instr listeinstr  | ;

var = {identif } identif | {varindexee} identif brackopen s brackclose ;
decvar = {declarationvar} type identif | {declarationvarindexee} type identif brackopen number brackclose ;
type = {entier} entier | {bool} bool ;
bool = {vrai} vrai | {faux} faux ;
decfonc = {declarationfonction} opttype identif l_par parametre r_par listedecvar instrbloc  ;
opttype = {type} type | ;
parametre={parametre} listedecvar ;
listedecvar = {listedecvar} decvar listedecvarbis | ;
listedecvarbis = {apreslistedecvar} virgule decvar listedecvarbis | ;

listedecfonc = {listedecfonc} decfonc listedecfonc | ;

