Package postfix;

Helpers
    lettre = [['a' .. 'z'] + ['A' .. 'Z']];
    chiffre = ['0' .. '9'];
    caractere = [lettre + chiffre];
    alpha = [lettre + ['_' + '$']];
    alphanum = [lettre + chiffre];
    entier = ('+' | '-')? ['0' .. '9'] ['0' .. '9']*;


Tokens
    number = chiffre+;
    vrai = 'vrai';
    faux = 'faux';
    plus = '+';
    minus = '-';
    ou = '|';
    et = '&';
    mult = '*';
    div = '/';
    mod = '%';
    l_par = '(';
    r_par = ')';
    non = '!';
    equal = '=';
    less = '<';
    t_huit = '_';
    espaces = (' ' | 13 | 10 | 9)+;
    saut_de_ligne = '\n';
    point_virgule = ';';
    brackopen  = '[';
    brackclose = ']';
    semicol    = ':';
    virgule = ',';
    l_accolade='{';
    r_accolade='}';
    lire = 'read';
    ecrire = 'write';

    plire = 'PLire';
    tlire = 'TLire';
    si = 'if';
    sinon = 'elseif';
    alors = 'then';
    tantque = 'while';
    faire = 'do';
    retour = 'return';
    epsilon = 'Îµ';
    entier = entier;

    commentaire= ';' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);

    identif = alpha alphanum* ;
Ignored Tokens
    espaces,commentaire;

Productions

s = {ou} s ou o |{o} o;
o = {et} o et e |{e} e;
e = {equal} p equal e |{less} p less e |{p} p;
p = {plus} p plus m |{minus} p minus m |{m} m;
m = {milt} n mult m |{div} n div m |{n} n;
n = {non} non f |{f} f;
f = {number} number | {vrai} vrai | {faux} faux | {variable} var | {parentese} l_par s r_par
                                                                     | {lire} lire l_par r_par ;

var = {identif } identif | {varindexee} identif brackopen s brackclose ;

instr = {afect} var equal s point_virgule |
    {si} si s alors instrbloc |
    {sinon} si s alors thenbranch sinon elsebranch |
    {tantque} tantque s faire instrbloc |
    {fonc} identif l_par listeexp r_par |
    {retour} retour s point_virgule|
    {ecrire} ecrire l_par s r_par point_virgule ;
listeexp = {listedeexpression} s listeexpbis |{vide} epsilon;
listeexpbis = {restelistedeexpression} virgule listeexpbis |{vide} epsilon;
thenbranch = {thenbranch} instrbloc;
elsebranch = {elsebranch} instrbloc;

instrbloc ={listedinstr} l_accolade listeinstr r_accolade ;
listeinstr = {listdeinstr}instr listeinstr  | {epsilon}epsilon ;

decvar = {declarationvar} type identif | {declarationvarindexee} type identif brackopen number brackclose ;
type = {entier} entier | {bool} bool ;
decfonc = {declarationfonction} opttype identif l_par parametre r_par listedecvar instrbloc ;
parametre={parametre} listedecvar ;
opttype = {type} type | {void} epsilon ;
listedecvar = {listedecvar} decvar listedecvarbis | {vide} epsilon ;
listedecvarbis = {apreslistedecvar} virgule decvar listedecvarbis | {vide} epsilon ;
bool = {vrai} vrai | {faux} faux ;

programme = {programme} listedecvar listedecfonc ;
listedecfonc = {listedecfonc} decfonc listedecfonc | {void} epsilon ;




